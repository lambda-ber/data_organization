{
  "contract_version": "0.1.0",
  "contract_name": "LAMBDA Data Organization Contract",
  "last_updated": "2025-12-05",
  "description": "Client-side data organization contract for LAMBDA federated bioimaging data architecture. This specification defines the required structure and metadata that facilities must provide when delivering data to LAMBDA consumers.",
  
  "directory_structure": {
    "root": "<experiment_id>",
    "required_root_structure": [
      "raw_data/",
      "products/",
      "raw_metadata/"
    ],
    "required_info_files": [
      "experiment_info.json",
      "raw_data/raw_data_info.json",
      "products/product_info.json",
      "raw_metadata/raw_metadata_info.json"
    ],
    "strict_root": true,
    "description": "Root must contain EXACTLY the three directories and one top-level JSON file listed above. No additional files or directories permitted."
  },

  "schemas": {
    "experiment_info": {
      "type": "object",
      "description": "Top-level experiment metadata",
      "required": [
        "contract_version",
        "experiment_id",
        "facility",
        "instrument",
        "technique",
        "date",
        "team",
        "sample_name"
      ],
      "properties": {
        "contract_version": {
          "type": "string",
          "description": "Version of LAMBDA contract this dataset conforms to",
          "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
          "examples": ["0.1.0"]
        },
        "experiment_id": {
          "type": "string",
          "description": "Globally unique identifier in UUID format (8-4-4-4-12 hexadecimal)",
          "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
          "examples": ["550e8400-e29b-41d4-a716-446655440000"]
        },
        "facility": {
          "type": "string",
          "description": "DOE facility name",
          "enum": ["ALS", "NSLSII", "APS", "SNS", "EMSL", "SLAC", "LCLS", "other"]
        },
        "instrument": {
          "type": "string",
          "description": "Specific beamline, microscope, or instrument identifier. Should use short acronym compatible with PDB listings where applicable.",
          "examples": ["BL8.3.1", "Titan Krios", "CXI"],
          "note": "TODO: Harmonize with PDB instrument naming conventions"
        },
        "technique": {
          "type": "string",
          "description": "Primary experimental technique. RX=rotation crystallography, SX=serial crystallography, SFX=serial femtosecond crystallography, EMD=electron microdiffraction, SEDX=serial electron diffraction",
          "enum": ["cryo-ET", "cryo-EM", "RX", "SX", "SFX", "SAXS", "WAXS", "SANS", "WANS", "XRD", "EMD", "SEDX", "other"]
        },
        "date": {
          "type": "string",
          "format": "date-time",
          "description": "Data collection date/time in ISO 8601 format with UTC timezone (must end with Z)",
          "pattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$",
          "examples": ["2025-03-15T14:30:00Z"]
        },
        "team": {
          "type": "object",
          "description": "Research team information",
          "required": ["PI"],
          "properties": {
            "PI": {
              "type": "object",
              "required": ["name", "institute", "orcid"],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Principal investigator name"
                },
                "institute": {
                  "type": "string",
                  "description": "Principal investigator institution"
                },
                "orcid": {
                  "type": "string",
                  "description": "ORCID identifier for principal investigator",
                  "pattern": "^[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{3}[0-9X]$",
                  "examples": ["0000-0002-1825-0097"]
                }
              }
            },
            "team_members": {
              "type": "array",
              "description": "Additional team members involved in data collection",
              "items": {
                "type": "object",
                "required": ["name", "institute"],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Team member name"
                  },
                  "institute": {
                    "type": "string",
                    "description": "Team member institution"
                  },
                  "orcid": {
                    "type": "string",
                    "description": "ORCID identifier (optional, but if provided must be valid)",
                    "pattern": "^[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{3}[0-9X]$",
                    "examples": ["0000-0002-1825-0097"]
                  }
                }
              }
            }
          }
        },
        "sample_name": {
          "type": "string",
          "description": "Short sample identifier",
          "examples": ["lysozyme", "SARS-CoV-2-spike", "apoferritin"]
        },
        "sample_composition": {
          "type": "string",
          "description": "High-level sample composition",
          "examples": ["protein in vitreous ice", "protein crystal", "DNA-protein complex"]
        },
        "sequence": {
          "type": "string",
          "description": "Protein/DNA/RNA sequence, ligands, cofactors"
        },
        "sample_description": {
          "type": "string",
          "description": "Detailed free-text sample description"
        },
        "related_experiments": {
          "type": "array",
          "items": {"type": "string"},
          "description": "Array of related experiment_ids for multi-facility campaigns"
        },
        "notes": {
          "type": "string",
          "description": "Additional free-text notes"
        }
      }
    },

    "raw_data_info": {
      "type": "object",
      "description": "Manifest of raw experimental data units",
      "required": ["units"],
      "properties": {
        "units": {
          "type": "array",
          "minItems": 1,
          "description": "Array of data units, where each unit represents data from a single biological sample",
          "items": {
            "type": "object",
            "required": ["id", "path", "description"],
            "properties": {
              "id": {
                "type": "string",
                "description": "Unique identifier for this data unit",
                "pattern": "^unit_[0-9]+$",
                "examples": ["unit_1", "unit_2"]
              },
              "path": {
                "type": "string",
                "description": "Relative path to unit directory from raw_data/",
                "pattern": "^\\./unit_[0-9]+/$",
                "examples": ["./unit_1/", "./unit_2/"]
              },
              "description": {
                "type": "string",
                "description": "Human-readable description of what this data unit represents",
                "examples": ["Tilt series from grid position A3", "Diffraction images from crystal 1"]
              },
              "files": {
                "type": "array",
                "description": "Optional detailed listing of files within this unit",
                "items": {
                  "type": "object",
                  "required": ["filename", "description", "sha256", "file_size", "mime_type"],
                  "properties": {
                    "filename": {
                      "type": "string",
                      "description": "Filename within unit directory"
                    },
                    "description": {
                      "type": "string",
                      "description": "What this file contains"
                    },
                    "type": {
                      "type": "string",
                      "description": "File type/format (optional)",
                      "examples": ["mrc", "tiff", "hdf5", "cbf"]
                    },
                    "sha256": {
                      "type": "string",
                      "description": "SHA256 checksum of file contents",
                      "pattern": "^[a-fA-F0-9]{64}$"
                    },
                    "file_size": {
                      "type": "integer",
                      "description": "File size in bytes",
                      "minimum": 0
                    },
                    "mime_type": {
                      "type": "string",
                      "description": "MIME type of file",
                      "examples": ["application/octet-stream", "image/tiff", "application/x-hdf"]
                    },
                    "allow_empty": {
                      "type": "boolean",
                      "description": "If true, zero-byte file is intentional (e.g., placeholder). Must be true for zero-byte files."
                    }
                  }
                }
              }
            }
          }
        }
      }
    },

    "product_info": {
      "type": "object",
      "description": "Manifest of derived data products",
      "required": ["products"],
      "properties": {
        "products": {
          "type": "array",
          "minItems": 0,
          "description": "Array of data products. Can be empty if no processing has occurred.",
          "items": {
            "type": "object",
            "required": ["id", "path", "description"],
            "properties": {
              "id": {
                "type": "string",
                "description": "Unique identifier for this product",
                "pattern": "^product_[0-9]+$",
                "examples": ["product_1", "product_2"]
              },
              "path": {
                "type": "string",
                "description": "Relative path to product directory from products/",
                "pattern": "^\\./product_[0-9]+/$",
                "examples": ["./product_1/", "./product_2/"]
              },
              "description": {
                "type": "string",
                "description": "What this product represents",
                "examples": ["IMOD tomographic reconstruction", "DIALS indexed reflections"]
              }
            }
          }
        }
      }
    },

    "workflow": {
      "type": "object",
      "description": "Provenance metadata for a single processing workflow execution. Must exist as workflow.json within each product directory.",
      "required": ["workflow_run_id", "task_name", "software", "version", "data_input", "outputs"],
      "properties": {
        "workflow_run_id": {
          "type": "string",
          "description": "Unique stable identifier for this workflow execution (UUID recommended)",
          "pattern": "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
          "examples": ["7c9e6679-7425-40de-944b-e07fc1f90ae7"]
        },
        "task_name": {
          "type": "string",
          "description": "Descriptive name of processing task",
          "examples": ["Tomographic reconstruction", "Structure refinement", "Peak integration"]
        },
        "software": {
          "type": "string",
          "description": "Software package name",
          "examples": ["IMOD", "RELION", "phenix.refine", "DIALS"]
        },
        "version": {
          "type": "string",
          "description": "Software version string",
          "examples": ["4.12.5", "v1.2.3", "2024.1"]
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When this workflow was executed in ISO 8601 UTC format (must end with Z)",
          "pattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$",
          "examples": ["2025-03-15T18:45:30Z"]
        },
        "data_input": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^(?!/)(?!.*\\.\\.)[A-Za-z0-9._\\-/]+$"
          },
          "description": "Array of relative paths to input files (relative to experiment root)",
          "examples": [
            ["raw_data/unit_1/tilt_series.mrc", "raw_data/unit_1/tilt_angles.txt"],
            ["products/product_1/indexed.refl", "raw_data/unit_1/strong_spots.cbf"]
          ]
        },
        "run_parameters": {
          "description": "Processing parameters: either path to parameter file (relative to product directory, must begin with ./) OR inline JSON object",
          "oneOf": [
            {
              "type": "string",
              "description": "Relative path to parameter file (relative to product directory, must begin with ./)",
              "pattern": "^\\./.+",
              "examples": ["./parameters.txt", "./config.json"]
            },
            {
              "type": "object",
              "description": "Inline parameter object",
              "examples": [{"binning": 2, "thickness": 1000}]
            }
          ]
        },
        "outputs": {
          "type": "array",
          "minItems": 1,
          "description": "Array of output files produced by this workflow",
          "items": {
            "type": "object",
            "required": ["filename", "description", "sha256", "file_size", "mime_type"],
            "properties": {
              "filename": {
                "type": "string",
                "description": "Output filename (within product directory)",
                "examples": ["reconstruction.mrc", "refined.pdb", "integrated.mtz"]
              },
              "type": {
                "type": "string",
                "description": "Output type classification",
                "examples": ["tomogram", "model", "plot", "log", "table"]
              },
              "description": {
                "type": "string",
                "description": "What this output contains",
                "examples": ["Aligned and reconstructed tomogram", "Refined atomic model"]
              },
              "sha256": {
                "type": "string",
                "description": "SHA256 checksum of file contents",
                "pattern": "^[a-fA-F0-9]{64}$"
              },
              "file_size": {
                "type": "integer",
                "description": "File size in bytes",
                "minimum": 0
              },
              "mime_type": {
                "type": "string",
                "description": "MIME type of file",
                "examples": ["application/octet-stream", "model/pdb", "chemical/x-cif"]
              },
              "allow_empty": {
                "type": "boolean",
                "description": "If true, zero-byte file is intentional (e.g., placeholder). Must be true for zero-byte files."
              },
              "schema_id": {
                "type": "string",
                "description": "Optional ID of an external product schema in a central registry (e.g. 'cryoet/tomogram/v1'). Validators MAY ignore unknown or missing schema_id in contract_version 0.1.x."
              }
            }
          }
        },
        "notes": {
          "type": "string",
          "description": "Additional notes about this workflow run"
        }
      }
    },

    "raw_metadata_info": {
      "type": "object",
      "description": "Manifest of auxiliary metadata files (calibrations, logs, external references)",
      "required": ["items"],
      "properties": {
        "items": {
          "type": "array",
          "minItems": 0,
          "description": "Array of metadata items. Can be empty if no auxiliary metadata exists.",
          "items": {
            "type": "object",
            "required": ["filename", "description", "sha256", "file_size", "mime_type"],
            "properties": {
              "filename": {
                "type": "string",
                "description": "Metadata filename (within raw_metadata directory)"
              },
              "description": {
                "type": "string",
                "description": "Human- and machine-interpretable description: must state file format, acquisition context, how it relates to the experiment, and units for numerical values where applicable. Must provide sufficient context to use the file without opening it.",
                "examples": [
                  "JSON file containing microscope calibration parameters (pixel size, beam tilt, defocus) measured on 2025-03-15",
                  "Plain text log of environmental conditions (temperature, humidity) during data collection, one reading per minute",
                  "MRC format dark reference image from detector, acquired immediately before data collection session"
                ]
              },
              "type": {
                "type": "string",
                "description": "Metadata category",
                "enum": ["calibration", "instrument_log", "environmental", "sample_preparation", "external_reference", "other"]
              },
              "sha256": {
                "type": "string",
                "description": "SHA256 checksum of file contents",
                "pattern": "^[a-fA-F0-9]{64}$"
              },
              "file_size": {
                "type": "integer",
                "description": "File size in bytes",
                "minimum": 0
              },
              "mime_type": {
                "type": "string",
                "description": "MIME type of file",
                "examples": ["application/json", "text/plain", "application/octet-stream"]
              },
              "allow_empty": {
                "type": "boolean",
                "description": "If true, zero-byte file is intentional (e.g., placeholder). Must be true for zero-byte files."
              }
            }
          }
        }
      }
    }
  },

  "controlled_vocabularies": {
    "facilities": [
      "ALS",
      "NSLSII",
      "APS",
      "SNS",
      "EMSL",
      "SLAC",
      "LCLS",
      "other"
    ],
    "techniques": [
      "cryo-ET",
      "cryo-EM",
      "RX",
      "SX",
      "SFX",
      "SAXS",
      "WAXS",
      "SANS",
      "WANS",
      "XRD",
      "EMD",
      "SEDX",
      "other"
    ],
    "product_types": [
      "reconstruction",
      "tomogram",
      "alignment",
      "segmentation",
      "model",
      "refinement",
      "analysis",
      "visualization",
      "other"
    ],
    "metadata_types": [
      "calibration",
      "instrument_log",
      "environmental",
      "sample_preparation",
      "external_reference",
      "other"
    ]
  },

  "validation_rules": {
    "root_directory": {
      "strict_enforcement": true,
      "allowed_contents": ["experiment_info.json", "raw_data/", "products/", "raw_metadata/"],
      "violation_message": "Root directory must contain EXACTLY four items: experiment_info.json and three subdirectories. Any additional files or directories are contract violations.",
      "hidden_files": "Reject any hidden files or system artifacts (e.g., .DS_Store, ._*, .gitkeep)",
      "symlinks": "Permit symlinks only if resolved target remains inside experiment root"
    },
    "experiment_id": {
      "format": "UUID in canonical 8-4-4-4-12 hexadecimal form",
      "assumed_unique": true,
      "collision_handling": "UUID collisions treated as negligibly probable; no central registry required"
    },
    "orcid": {
      "PI_required": true,
      "team_members_optional": true,
      "validation": "If provided, must satisfy ORCID checksum rules"
    },
    "technique_instrument_consistency": {
      "description": "Maintain mapping of allowed technique-instrument pairs",
      "enforcement": "Reject any combination not explicitly whitelisted",
      "note": "Specific mappings to be defined per facility"
    },
    "biological_sequences": {
      "formats": ["FASTA format", "single-line canonical IUPAC code"],
      "validation": "Apply these checks to experiment_info.sequence. If its first character is '>', require FASTA format. Otherwise, expect a single-line canonical sequence string. Validator should check basic format consistency but sequence alphabet enforcement is deferred to domain-specific tools.",
      "minimum_length": 1
    },
    "raw_unit_definition": {
      "rule": "One unit = one physical biological specimen",
      "multiple_runs": "Multiple runs from same specimen must be subdirectories of that unit",
      "reject": "Multiple physical samples collapsed into one unit"
    },
    "paths": {
      "format": "relative; may optionally start with ./",
      "directories": "Fields that represent directory paths MUST end with /. Fields that represent file paths MUST NOT end with /.",
      "safety": "Resolve every path; reject any that uses .. or escapes experiment root through symlink traversal",
      "no_absolute_paths": true,
      "no_urls": "URLs not permitted inside path fields",
      "no_parent_segments": "Path components must not include ..; paths are always evaluated relative to experiment root or explicitly stated base directory"
    },
    "file_manifest_integrity": {
      "required_fields": ["sha256", "file_size", "mime_type"],
      "sha256": "256-bit hexadecimal checksum",
      "reject_mismatched": true,
      "zero_byte_files": "Reject files with file_size = 0 unless allow_empty is true",
      "scope": "If a files array is present for a raw data unit, it must enumerate all files in that directory; missing files are considered violations."
    },
    "product_provenance": {
      "workflow_json": "Exactly one workflow.json per product directory",
      "workflow_run_id": "Must be unique and stable UUID",
      "reject_multiple": "Reject if multiple workflow definitions exist"
    },
    "timestamps": {
      "format": "ISO 8601 UTC with explicit Z suffix",
      "reject": "local-time timestamps or timezone offsets",
      "pattern": "YYYY-MM-DDTHH:MM:SSZ"
    },
    "raw_metadata_descriptions": {
      "semantic_completeness": ["file format", "acquisition context", "semantic linkage to experiment", "units for numerical values"],
      "reject": "vague or incomplete descriptions"
    },
    "vocabulary_extensions": {
      "wrapper": "All extension fields must be within an _extensions_ object",
      "required_meta": "Extensions should include _meta object with facility, version, and documentation",
      "required_documentation": ["definition text for each field", "provenance", "sponsoring facility in _meta"],
      "reject": "extension fields outside _extensions_ wrapper or lacking proper documentation"
    },
    "sequential_numbering": {
      "units": "Strictly sequential with no gaps: unit_1, unit_2, ...",
      "products": "Strictly sequential with no gaps: product_1, product_2, ...",
      "reject": "missing intermediate indices"
    },
    "json_files": {
      "encoding": "UTF-8",
      "format": "valid JSON (no trailing commas, proper escaping)",
      "validation": "Must validate against corresponding schema"
    },
    "workflow_reproducibility": {
      "version_identifiers": "Explicit version strings required; reject 'latest', 'current', or Git branches",
      "completeness": "List ALL input files and ALL generated outputs",
      "reject": "partial provenance"
    },
    "forbidden_content": {
      "reject": [
        "absolute paths",
        "URLs inside path fields",
        "encrypted files without decryption keys",
        "proprietary binary blobs lacking format specification"
      ]
    },
    "schema_version_coupling": {
      "declaration": "Each dataset must declare exact contract_version used",
      "validation": "Validator must compare experiment_info.contract_version to its own contract_version. If major or minor version differ, dataset MUST be rejected unless explicitly handled by a compatibility layer. Patch-level differences (e.g., 0.1.0 vs 0.1.1) MAY be accepted if declared compatible by the implementation."
    },
    "external_schemas": {
      "description": "workflow.outputs[*].schema_id may declare an optional schema identifier referring to a central schema registry.",
      "enforcement_0_1_x": "In contract_version 0.1.x, validators MUST NOT fail a dataset solely because schema_id is missing or unknown.",
      "future_evolution": "Future contract versions or addendums MAY require specific schema_id values for certain techniques or products and enforce external schema validation."
    },
    "error_handling": {
      "severity": "All violations are fatal; no warnings",
      "output_format": ["rule violated", "path to offending file", "expected vs actual value"]
    }
  },

  "extension_points": {
    "technique_specific_fields": {
      "description": "Additional fields can be added for technique-specific metadata using an _extensions_ wrapper object",
      "namespace": "All extension fields must be placed inside an _extensions_ object at the appropriate schema level",
      "allowed_locations": [
        "experiment_info.json (root level)",
        "raw_data/raw_data_info.json units (per-unit level)",
        "products/product_N/workflow.json (per-workflow level)",
        "raw_metadata/raw_metadata_info.json items (per-item level)"
      ],
      "exhaustive": "This list is exhaustive; _extensions_ is not permitted at any other location in the contract",
      "structure": {
        "_meta": {
          "description": "Optional metadata about the extensions themselves",
          "fields": ["facility", "version", "documentation"]
        },
        "extension_fields": "Arbitrary fields specific to technique, facility, or workflow"
      },
      "example": {
        "_extensions_": {
          "_meta": {
            "facility": "ALS",
            "version": "1.0",
            "documentation": "https://als.lbl.gov/lambda-extensions"
          },
          "tilt_range": [-60, 60],
          "detector_distance": 5.0
        }
      },
      "coordinate_frames": "Facilities MAY include coordinate_frame within _extensions_ (e.g., pixel_size, axis_convention, handedness, detector_distance) if convenient, but this is NOT required in contract_version 0.1.x."
    },
    "custom_vocabularies": {
      "description": "Facilities can propose additions to controlled vocabularies",
      "process": "Submit via LAMBDA governance process with use case justification"
    },
    "schema_evolution": {
      "description": "Contract versions follow semantic versioning",
      "backwards_compatibility": "Minor version updates (0.x.0) maintain backwards compatibility. Major version updates (x.0.0) may introduce breaking changes."
    }
  },

  "implementation_notes": {
    "federation_model": "Facilities maintain internal data organization but must provide translation layer to this contract format",
    "translation_determinism": "Translation must be deterministic: same internal dataset must always yield identical contract output, byte-for-byte. If translation is lossy, required fields must document what information cannot be preserved.",
    "data_scope": "One experiment = one sample type, one facility, one collection session",
    "data_unit_definition": "One unit = data from single biological sample",
    "product_definition": "One product = output from single software/pipeline execution (single command/workflow)",
    "symlinks_vs_copies": "Implementation may use symlinks or copies; contract specifies logical structure only",
    "partial_compliance": "Facilities unable to provide optional fields should omit them. Missing required fields constitute contract violations.",
    "validation_tooling": "Reference validator implementation available at [TBD]",
    "workflow_executability": "Future work: certification that stated software/pipeline can run with stated inputs. Currently focuses on data provenance rather than computational reproducibility infrastructure.",
    "root_evolution": "contract_version 0.1.x requires exactly four items at the experiment root: experiment_info.json, raw_data/, products/, raw_metadata/. Future contract versions MAY expand the allowed root contents via explicit contract revision; additional directories are not permitted in 0.1.x."
  },

  "validator_directive": {
    "purpose": "Strict validator for LAMBDA Data Organization Contract",
    "input": "Experiment directory path and its JSON manifests",
    "output": "Either { status: 'ok' } or array of error objects",
    "error_format": {
      "rule": "specific rule name from validation_rules",
      "path": "filesystem path to offending file/directory (relative to experiment root)",
      "json_pointer": "JSON Pointer to offending field in manifest (if applicable)",
      "expected": "concise description of what the rule requires",
      "actual": "the value or condition observed"
    },
    "steps": [
      "1. Validate directory structure: enforce validation_rules.root_directory exactly, including hidden-files rejection and symlink containment",
      "2. Validate each JSON file against its JSON Schema definition under schemas and global validation_rules. JSON Schema validity is necessary but not sufficient",
      "3. Enforce all cross-cutting rules in validation_rules even when not expressible as JSON Schema: UUID syntax, ORCID format, path normalization and safety, sequential numbering, timestamp constraints, biological sequences, zero-byte files, checksums, provenance, reproducibility, extensions, forbidden content, version coupling",
      "4. When a rule is violated, stop considering that dataset valid. Output error object for each violation",
      "5. If and only if all rules pass, output { status: 'ok' }"
    ],
    "severity": "All violations are fatal; no warnings permitted"
  }
}
